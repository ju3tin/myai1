<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PoseNet Exercise Detector</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            text-align: center;
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #video, #canvas {
            margin-top: 10px;
            border: 1px solid #ccc;
        }
        #status {
            margin-top: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        #counter {
            margin-top: 10px;
            font-size: 24px;
            font-weight: bold;
        }
        button {
            margin: 10px;
            padding: 8px 16px;
            background-color: #4285f4;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #3367d6;
        }
        select {
            margin: 10px;
            padding: 8px;
        }
        input[type="number"] {
            margin: 10px;
            padding: 8px;
            width: 60px;
        }
    </style>
    <!-- TensorFlow.js Core -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.17.0/dist/tf.min.js"></script>
    <!-- TensorFlow.js Models (PoseNet) -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.0.0/dist/pose-detection.min.js"></script>
</head>
<body>
    <h1>PoseNet Exercise Detector</h1>
    <div class="container">
        <div>
            <select id="exerciseSelect">
                <option value="pushups">Push-ups</option>
                <option value="situps">Sit-ups</option>
                <option value="starjumps">Star Jumps</option>
                <option value="squats">Squats</option>
                <option value="lunges">Lunges</option>
                <option value="burpees">Burpees</option>
            </select>
            <button id="startBtn">Start Camera</button>
            <button id="stopBtn" disabled>Stop Camera</button>
        </div>
        <div>
            <input type="number" id="goalInput" placeholder="Reps Goal" />
            <button id="setGoalBtn">Set Goal</button>
        </div>
        <video id="video" width="640" height="480" autoplay style="display: none;"></video>
        <canvas id="canvas" width="640" height="480"></canvas>
        <div id="status">Loading models...</div>
        <div id="counter">Reps: 0</div>
        <div id="formFeedback">Form: Good</div>
    </div>
    <script>
        let detector;
        let video;
        let canvas;
        let ctx;
        let isRunning = false;
        let rafId;
        let exercise = 'pushups';
        let repCount = 0;
        let prevState = null;
        let lastPose = null;
        let repGoal = null;

        // DOM elements
        const statusDiv = document.getElementById('status');
        const counterDiv = document.getElementById('counter');
        const formFeedbackDiv = document.getElementById('formFeedback');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const exerciseSelect = document.getElementById('exerciseSelect');
        const goalInput = document.getElementById('goalInput');
        const setGoalBtn = document.getElementById('setGoalBtn');

        // Initialize the application
        async function init() {
            statusDiv.textContent = 'Loading TensorFlow.js...';

            if (!window.poseDetection) {
                statusDiv.textContent = 'Error: Pose Detection library not loaded.';
                return;
            }

            await tf.ready();

            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            video = document.getElementById('video');

            startBtn.addEventListener('click', startCamera);
            stopBtn.addEventListener('click', stopCamera);
            exerciseSelect.addEventListener('change', changeExercise);
            setGoalBtn.addEventListener('click', setGoal);

            await loadModel();

            statusDiv.textContent = 'Model loaded. Select an exercise and click "Start Camera" to begin.';
        }

        // Load PoseNet model
        async function loadModel() {
            if (detector) {
                detector.dispose();
                detector = null;
            }

            statusDiv.textContent = 'Loading PoseNet model...';

            try {
                const modelConfig = {
                    architecture: 'MobileNetV1',
                    outputStride: 16,
                    inputResolution: { width: 640, height: 480 },
                    multiplier: 0.75
                };
                detector = await poseDetection.createDetector(
                    poseDetection.SupportedModels.PoseNet,
                    modelConfig
                );
                statusDiv.textContent = 'PoseNet model loaded!';
            } catch (error) {
                statusDiv.textContent = `Error loading model: ${error.message}`;
                console.error(error);
            }
        }

        // Start the camera and pose detection
        async function startCamera() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                statusDiv.textContent = 'Error: Camera access not supported in this browser.';
                return;
            }

            try {
                const constraints = {
                    video: { width: 640, height: 480 }
                };
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;

                video.onloadedmetadata = () => {
                    video.play();
                    video.style.display = 'none';
                    startBtn.disabled = true;
                    stopBtn.disabled = false;
                    exerciseSelect.disabled = true;
                    isRunning = true;
                    statusDiv.textContent = `Camera started. Detecting ${exercise}...`;
                    detectPose();
                };
            } catch (error) {
                statusDiv.textContent = `Error accessing camera: ${error.message}`;
                console.error(error);
            }
        }

        // Stop the camera and pose detection
        function stopCamera() {
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }

            if (rafId) {
                cancelAnimationFrame(rafId);
                rafId = null;
            }

            startBtn.disabled = false;
            stopBtn.disabled = true;
            exerciseSelect.disabled = false;
            isRunning = false;
            repCount = 0;
            prevState = null;
            counterDiv.textContent = 'Reps: 0';
            statusDiv.textContent = 'Camera stopped.';

            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // Change the exercise
        function changeExercise() {
            exercise = exerciseSelect.value;
            repCount = 0;
            prevState = null;
            counterDiv.textContent = 'Reps: 0';
            statusDiv.textContent = `Selected ${exercise}. Click "Start Camera" to begin.`;
        }

        // Set the rep goal
        function setGoal() {
            const goal = parseInt(goalInput.value, 10);
            if (!isNaN(goal) && goal > 0) {
                repGoal = goal;
                statusDiv.textContent = `Rep Goal Set: ${repGoal} reps.`;
            } else {
                statusDiv.textContent = 'Please enter a valid number for the goal.';
            }
        }

        // Detect exercise and count reps
        function detectExercise(pose) {
            const keypointMap = {};
            pose.keypoints.forEach(keypoint => {
                keypointMap[keypoint.part] = keypoint;
            });

            const requiredKeypoints = [
                keypointMap.leftShoulder, keypointMap.rightShoulder,
                keypointMap.leftElbow, keypointMap.rightElbow,
                keypointMap.leftWrist, keypointMap.rightWrist,
                keypointMap.leftHip, keypointMap.rightHip,
                keypointMap.leftKnee, keypointMap.rightKnee
            ];

            if (requiredKeypoints.some(kp => !kp || kp.score < 0.3)) {
                return null;
            }

            let state = null;

            if (exercise === 'pushups') {
                const shoulderY = (keypointMap.leftShoulder.y + keypointMap.rightShoulder.y) / 2;
                const elbowAngle = calculateAngle(
                    keypointMap.leftShoulder, keypointMap.leftElbow, keypointMap.leftWrist
                );
                state = shoulderY > 300 && elbowAngle < 100 ? 'down' : 'up';
            } else if (exercise === 'situps') {
                const hip = keypointMap.leftHip;
                const shoulder = keypointMap.leftShoulder;
                const knee = keypointMap.leftKnee;
                const torsoAngle = calculateAngle(shoulder, hip, knee);
                state = torsoAngle < 60 ? 'up' : 'down';
            } else if (exercise === 'starjumps') {
                const wristDistance = Math.abs(keypointMap.leftWrist.x - keypointMap.rightWrist.x);
                const ankleDistance = Math.abs(keypointMap.leftAnkle.x - keypointMap.rightAnkle.x);
                state = wristDistance > 400 && ankleDistance > 400 ? 'open' : 'closed';
            } else if (exercise === 'squats') {
                const hipY = (keypointMap.leftHip.y + keypointMap.rightHip.y) / 2;
                const kneeAngle = calculateAngle(
                    keypointMap.leftHip, keypointMap.leftKnee, keypointMap.leftAnkle
                );
                state = hipY > 300 && kneeAngle < 100 ? 'down' : 'up';
            } else if (exercise === 'lunges') {
                // Lunges Logic
            } else if (exercise === 'burpees') {
                // Burpees Logic
            }

            // Feedback and rep counting logic
            let formFeedback = 'Form: Good';
            if (state === 'down') {
                formFeedback = 'Form: Good!';
            } else {
                formFeedback = 'Form: Keep it up!';
            }

            formFeedbackDiv.textContent = formFeedback;

            if (prevState && state !== prevState) {
                if (
                    (exercise === 'pushups' && prevState === 'up' && state === 'down') ||
                    (exercise === 'situps' && prevState === 'down' && state === 'up') ||
                    (exercise === 'starjumps' && prevState === 'closed' && state === 'open') ||
                    (exercise === 'squats' && prevState === 'up' && state === 'down')
                ) {
                    repCount++;
                    counterDiv.textContent = `Reps: ${repCount}`;
                    if (repGoal && repCount >= repGoal) {
                        statusDiv.textContent = 'Goal reached!';
                        stopCamera();
                    }
                }
            }

            prevState = state;
            return state;
        }

        // Calculate angle between three points
        function calculateAngle(p1, p2, p3) {
            const vector1 = { x: p1.x - p2.x, y: p1.y - p2.y };
            const vector2 = { x: p3.x - p2.x, y: p3.y - p2.y };
            const dotProduct = vector1.x * vector2.x + vector1.y * vector2.y;
            const magnitude1 = Math.sqrt(vector1.x ** 2 + vector1.y ** 2);
            const magnitude2 = Math.sqrt(vector2.x ** 2 + vector2.y ** 2);
            const cosTheta = dotProduct / (magnitude1 * magnitude2);
            return Math.acos(Math.max(-1, Math.min(1, cosTheta))) * (180 / Math.PI);
        }

        // Continuously detect poses
        async function detectPose() {
            if (!isRunning || !detector || video.readyState !== 4) {
                rafId = requestAnimationFrame(detectPose);
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            try {
                const poses = await detector.estimatePoses(video);
                if (poses.length > 0) {
                    const state = detectExercise(poses[0]);
                    drawPoses(poses);
                    statusDiv.textContent = `Detecting ${exercise}... ${state ? `State: ${state}` : 'No clear pose detected'}`;
                } else {
                    statusDiv.textContent = `Detecting ${exercise}... No poses detected`;
                }
            } catch (error) {
                console.error('Error detecting poses:', error);
                statusDiv.textContent = `Error detecting poses: ${error.message}`;
            }

            rafId = requestAnimationFrame(detectPose);
        }

        // Draw detected poses on the canvas
        function drawPoses(poses) {
            for (const pose of poses) {
                for (const keypoint of pose.keypoints) {
                    if (keypoint.score > 0.3) {
                        ctx.beginPath();
                        ctx.arc(keypoint.x, keypoint.y, 5, 0, 2 * Math.PI);
                        ctx.fillStyle = 'red';
                        ctx.fill();
                        ctx.fillStyle = 'white';
                        ctx.font = '12px Arial';
                        ctx.fillText(keypoint.part, keypoint.x + 10, keypoint.y + 5);
                    }
                }
                if (pose.keypoints.length > 5) {
                    drawSkeleton(pose);
                }
            }
        }

        // Draw the skeleton
        function drawSkeleton(pose) {
            const connections = [
                ['nose', 'leftEye'], ['nose', 'rightEye'],
                ['leftEye', 'leftEar'], ['rightEye', 'rightEar'],
                ['nose', 'leftShoulder'], ['nose', 'rightShoulder'],
                ['leftShoulder', 'leftElbow'], ['rightShoulder', 'rightElbow'],
                ['leftElbow', 'leftWrist'], ['rightElbow', 'rightWrist'],
                ['leftShoulder', 'rightShoulder'],
                ['leftShoulder', 'leftHip'], ['rightShoulder', 'rightHip'],
                ['leftHip', 'rightHip'],
                ['leftHip', 'leftKnee'], ['rightHip', 'rightKnee'],
                ['leftKnee', 'leftAnkle'], ['rightKnee', 'rightAnkle']
            ];

            const keypointMap = {};
            pose.keypoints.forEach(keypoint => {
                keypointMap[keypoint.part] = keypoint;
            });

            ctx.strokeStyle = 'green';
            ctx.lineWidth = 4;

            for (const [p1Name, p2Name] of connections) {
                const p1 = keypointMap[p1Name];
                const p2 = keypointMap[p2Name];

                if (p1 && p2 && p1.score > 0.3 && p2.score > 0.3) {
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }
            }
        }

        // Start the application
        init();
    </script>
</body>
</html>
